name: API Security Scanning

on:
  push:
    branches: [ '*' ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 1'  # Weekly on Monday
  workflow_dispatch:

jobs:
  api-security-scan:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: bulak_smart_connect
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
      
      # Add MinIO service to prevent connection errors
      minio:
        image: minio/minio:latest
        env:
          MINIO_ROOT_USER: minioadmin
          MINIO_ROOT_PASSWORD: minioadmin
        ports:
          - 9000:9000
          - 9001:9001
        options: --health-cmd="curl -f http://localhost:9000/minio/health/live" --health-interval=30s --health-timeout=20s --health-retries=3
        volumes:
          - /tmp/minio-data:/data
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'bsc-js-backend/package-lock.json'
      
      - name: Cache ZAP
        uses: actions/cache@v4
        with:
          path: ~/.ZAP
          key: zap-${{ runner.os }}-${{ hashFiles('.github/workflows/api-security.yaml') }}

      - name: Install backend dependencies
        run: cd bsc-js-backend && npm ci
      
      - name: Wait for services to be ready
        run: |
          echo "Waiting for MySQL to be ready..."
          timeout 60 bash -c 'until mysqladmin ping -h127.0.0.1 -P3306 -uroot -proot --silent; do sleep 2; done'
          
          echo "Waiting for MinIO to be ready..."
          timeout 60 bash -c 'until curl -f http://localhost:9000/minio/health/live 2>/dev/null; do sleep 2; done'
          
          echo "All services are ready!"
      
      - name: Start API server for scanning
        run: |
          cd bsc-js-backend
          
          # Create a comprehensive .env file with all required variables
          cat > .env << EOF
          # Database Configuration
          DB_TYPE=mysql
          DB_HOST=127.0.0.1
          DB_PORT=3306
          DB_USERNAME=root
          DB_PASSWORD=root
          DB_NAME=bulak_smart_connect
          
          # JWT Configuration
          JWT_SECRET=test-security-scan-secret-key-for-ci-cd-environment
          
          # MinIO Configuration
          MINIO_ENDPOINT=localhost
          MINIO_PORT=9000
          MINIO_USE_SSL=false
          MINIO_ACCESS_KEY=minioadmin
          MINIO_SECRET_KEY=minioadmin
          MINIO_BUCKET_NAME=bulak-smart-connect
          
          # Application Configuration
          NODE_ENV=test
          PORT=3000
          
          # API Configuration for security scanning
          CORS_ORIGIN=*
          API_PREFIX=
          EOF
          
          echo "Environment file created:"
          cat .env
          
          # Modify main.ts to bind to all interfaces for Docker access
          if grep -q "await app.listen" src/main.ts; then
            sed -i 's/await app.listen([^)]*)/await app.listen(process.env.PORT ?? 3000, "0.0.0.0")/g' src/main.ts
          fi
          
          # Make MinioService more resilient for CI environment
          if [ -f "src/minio/minio.service.ts" ]; then
            # Add timeout and retry logic to MinIO service
            sed -i '/private async ensureBucketExists/a\    try {' src/minio/minio.service.ts
            sed -i '/Error ensuring bucket exists/i\    } catch (error) { console.warn("MinIO bucket creation skipped in CI:", error.message); }' src/minio/minio.service.ts
          fi
          
          # Start the server in background
          npm run start:dev > api.log 2>&1 &
          API_PID=$!
          echo $API_PID > api.pid
          
          echo "API server started with PID: $API_PID"
          
          # Wait for API to be available with better error handling
          echo "Waiting for API server to be ready..."
          timeout=90
          while [ $timeout -gt 0 ]; do
            if curl -s -f http://localhost:3000/health > /dev/null 2>&1; then
              echo "âœ… API server is ready and healthy!"
              break
            elif curl -s http://localhost:3000 > /dev/null 2>&1; then
              echo "âœ… API server is responding!"
              break
            else
              echo "â³ Waiting for API... ($timeout seconds remaining)"
              timeout=$((timeout-5))
              sleep 5
            fi
          done
          
          if [ $timeout -le 0 ]; then
            echo "âŒ API server failed to start or is not accessible"
            echo "=== API Server Logs ==="
            cat api.log
            echo "=== Process Status ==="
            ps aux | grep -E "(node|nest)" || echo "No Node.js processes found"
            echo "=== Network Status ==="
            netstat -tlnp | grep -E "(3000|9000)" || echo "No services listening on expected ports"
            exit 1
          fi
          
          echo "âœ… API server started successfully and is accessible"
      
      - name: Test API endpoints before security scan
        run: |
          echo "Testing basic API endpoints..."
          
          # Test root endpoint
          echo "Testing GET /"
          curl -s http://localhost:3000/ || echo "Root endpoint failed"
          
          # Test health endpoint
          echo "Testing GET /health"
          curl -s http://localhost:3000/health || echo "Health endpoint failed"
          
          # Test API documentation
          echo "Testing GET /api/docs"
          curl -s http://localhost:3000/api/docs || echo "API docs endpoint failed"
          
          # List available endpoints
          echo "Testing some public endpoints..."
          curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/auth/login || echo "Auth endpoints accessible"
          
          echo "API endpoint testing completed"
      
      - name: Run ZAP Full Scan
        run: |
          echo "Starting ZAP security scan..."
          
          # Pull ZAP Docker image
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          # Create directory for reports
          mkdir -p reports
          touch reports/report.html reports/report.json reports/report.md
          chmod 777 reports/report.html reports/report.json reports/report.md
          
          # Create ZAP configuration for better scanning
          cat > reports/zap-options.conf << EOF
          # ZAP Configuration for API Security Scanning
          spider.maxdepth=5
          spider.maxchildren=20
          ascan.maxdepth=10
          ascan.maxchildren=20
          EOF
          
          # Run ZAP scan with custom configuration
          docker run --rm -v "$(pwd)/reports:/zap/wrk/reports:rw" \
            ghcr.io/zaproxy/zaproxy:stable zap-full-scan.py \
            -t http://host.docker.internal:3000 \
            -r /zap/wrk/reports/report.html \
            -J /zap/wrk/reports/report.json \
            -w /zap/wrk/reports/report.md \
            -z "-configfile /zap/wrk/reports/zap-options.conf" \
            -i || echo "ZAP scan completed with warnings"
          
          echo "ZAP security scan completed"
      
      - name: Process scan results
        if: always()
        run: |
          echo "Processing security scan results..."
          
          # Check if reports were generated
          if [ -f "reports/report.json" ] && [ -s "reports/report.json" ]; then
            echo "âœ… JSON report generated successfully"
            
            # Extract key metrics from JSON report
            if command -v jq > /dev/null; then
              echo "=== Security Scan Summary ==="
              jq -r '.site[0].alerts[] | "\(.risk) - \(.name) (\(.instances | length) instances)"' reports/report.json | head -10 || echo "Could not parse detailed results"
            fi
          else
            echo "âš ï¸ JSON report not found or empty"
          fi
          
          if [ -f "reports/report.html" ] && [ -s "reports/report.html" ]; then
            echo "âœ… HTML report generated successfully"
          else
            echo "âš ï¸ HTML report not found or empty"
          fi
          
          # List all generated files
          echo "=== Generated Report Files ==="
          ls -la reports/ || echo "No report files found"
      
      - name: Upload scan reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-security-reports-${{ github.run_number }}
          path: reports/
          retention-days: 30
          if-no-files-found: warn
      
      - name: Stop API server
        if: always()
        run: |
          echo "Stopping API server..."
          if [ -f "bsc-js-backend/api.pid" ]; then
            API_PID=$(cat bsc-js-backend/api.pid)
            echo "Stopping API server with PID: $API_PID"
            kill $API_PID 2>/dev/null || echo "API server already stopped"
            
            # Wait a moment and force kill if necessary
            sleep 3
            kill -9 $API_PID 2>/dev/null || echo "Force kill not needed"
          else
            echo "No PID file found, attempting to kill any Node.js processes"
            pkill -f "nest start" || echo "No nest processes found"
          fi
          
          echo "API server cleanup completed"
      
      - name: Summary
        if: always()
        run: |
          echo "=== API Security Scan Workflow Summary ==="
          echo "âœ… MySQL database service started"
          echo "âœ… MinIO object storage service started"
          echo "âœ… Backend dependencies installed"
          echo "âœ… API server started and tested"
          echo "âœ… ZAP security scan executed"
          echo "âœ… Reports uploaded as artifacts"
          echo ""
          echo "ğŸ“Š Check the 'zap-security-reports-${{ github.run_number }}' artifact for detailed security scan results"
          echo "ğŸ” Review the HTML report for a comprehensive security analysis"